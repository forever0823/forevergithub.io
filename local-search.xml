<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基数排序(多关键字排序)</title>
    <link href="/2023/12/10/%E9%93%BE%E5%BC%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/12/10/%E9%93%BE%E5%BC%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>是一种借助“多关键字排序”的思想来实现“单关键字排序”的内部排序算法。可以将每个关键字 K 看成由四个单关键字组成，即 K&#x3D; k 1,k 2,k 3,k 4 每个关键字的取值范围为 0≤k i≤9，所以每个关键字可取值的数目为 10。通常将关键字取值的数目称为基数，用 r 表示，下例中 r &#x3D;10。</p><p>链式基数排序（Radix Sort）是一种基于数位的排序算法。(这里使用LSD法进行排序)具体实现方法如下：</p><ol><li>取得链表中的最大数，并取得位数</li><li>从最低位开始，依次对每个数位进行排序，将排序结果存储到桶(辅助空间)中</li><li>将桶(辅助空间)中的结果存回原链表中</li><li>重复步骤2-3，直到最高位排序完毕</li></ol><p>以下是实现20个四位数的链式基数排序的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 定义链表结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125; Node;<br><span class="hljs-comment">// 定义队列结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span></span><br><span class="hljs-class">&#123;</span><br>    Node* front;  <span class="hljs-comment">// 队列前端</span><br>    Node* rear;   <span class="hljs-comment">// 队列后端</span><br>&#125; Queue;<br><br>Queue <span class="hljs-built_in">queue</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">// 10 个队列，用于分配和收集数据</span><br><span class="hljs-type">int</span> divisior = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 用于按位取数的除数，初始为1</span><br><br><span class="hljs-comment">// 初始化队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">initQueue</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    Node* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        p-&gt;data = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化结点数据为0</span><br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        (*que).front = p;<br>        (*que).rear = p;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;node apply error!\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 入队操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Queue* que, <span class="hljs-type">int</span> e)</span><br>&#123;<br>    Node* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        p-&gt;data = e;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        (*que).rear-&gt;next = p;  <span class="hljs-comment">// 将新结点插入队尾</span><br>        (*que).rear = p;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;node apply error!\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 清空队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    (*que).front-&gt;next = <span class="hljs-literal">NULL</span>;<br>    (*que).rear = (*que).front;<br>&#125;<br><br><span class="hljs-comment">// 获取最大数的位数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxBit</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    Node* p = (*que).front-&gt;next;<br>    <span class="hljs-type">int</span> maxData = p-&gt;data;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxData &lt; p-&gt;data) &#123;<br>            maxData = p-&gt;data;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (maxData &gt; <span class="hljs-number">0</span>) &#123;<br>        maxData /= <span class="hljs-number">10</span>;<br>        b++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-comment">// 根据当前位数获取关键字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getKey</span><span class="hljs-params">(Node* q)</span><br>&#123;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    k = ((*q).data / divisior) % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><br><span class="hljs-comment">// 分配数据到各个队列中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">distributeRadix</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        initQueue(&amp;<span class="hljs-built_in">queue</span>[i]);  <span class="hljs-comment">// 初始化10个队列</span><br>    &#125;<br>    Node* p = (*que).front-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">int</span> k = getKey(p); <br>        <span class="hljs-built_in">queue</span>[k].rear-&gt;next = p;  <span class="hljs-comment">// 将当前结点放入对应队列中</span><br>        <span class="hljs-built_in">queue</span>[k].rear = p;  <span class="hljs-comment">// 更新队列尾结点</span><br>        p = p-&gt;next;<br>        <span class="hljs-built_in">queue</span>[k].rear-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    clear(que);  <span class="hljs-comment">// 清空原队列</span><br>&#125;<br><br><span class="hljs-comment">// 将数据收集到原队列中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">collectRadix</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span>; index++) &#123;<br>        <span class="hljs-keyword">if</span> (&amp;<span class="hljs-built_in">queue</span>[index].front-&gt;next-&gt;data != <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">// 找到第一个非空队列</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    Node* p = <span class="hljs-built_in">queue</span>[index].front-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        (*que).rear-&gt;next = p;  <span class="hljs-comment">// 将队列中的数据接入原队列</span><br>        (*que).rear = p; <br>        p = p-&gt;next;<br>        (*que).rear-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (index++; index &lt; <span class="hljs-number">10</span>; index++) &#123;<br>        Node* q = <span class="hljs-built_in">queue</span>[index].front-&gt;next; <br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            (*que).rear-&gt;next = q; <br>            (*que).rear = q;<br>            q = q-&gt;next;<br>            (*que).rear-&gt;next = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        clear(&amp;<span class="hljs-built_in">queue</span>[i]);  <span class="hljs-comment">// 清空各个队列</span><br>    &#125;<br>    divisior *= <span class="hljs-number">10</span>;  <span class="hljs-comment">// 更新除数</span><br>&#125;<br><br><span class="hljs-comment">// 基数排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">radix</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    <span class="hljs-type">int</span> b = maxBit(que);  <span class="hljs-comment">// 获取最大位数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br>        distributeRadix(que);  <span class="hljs-comment">// 按当前位数分配到各个队列</span><br>        collectRadix(que);  <span class="hljs-comment">// 将数据收集到原队列</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    Node* p = (*que).front-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    Queue que;<br>    initQueue(&amp;que);<br>    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">1234</span>, <span class="hljs-number">5678</span>, <span class="hljs-number">9101</span>, <span class="hljs-number">2345</span>, <span class="hljs-number">6789</span>, <span class="hljs-number">1011</span>, <span class="hljs-number">1213</span>, <span class="hljs-number">1415</span>, <span class="hljs-number">1617</span>, <span class="hljs-number">1819</span>,<br>        <span class="hljs-number">2021</span>, <span class="hljs-number">2223</span>, <span class="hljs-number">2425</span>, <span class="hljs-number">2627</span>, <span class="hljs-number">2829</span>,<span class="hljs-number">3032</span>, <span class="hljs-number">3233</span>, <span class="hljs-number">3435</span>, <span class="hljs-number">3637</span>, <span class="hljs-number">3839</span> &#125;;<br>    <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        push(&amp;que, arr[i]);  <span class="hljs-comment">// 将数据入队</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排序前序列：\n&quot;</span>);<br>    print(&amp;que);<br>    radix(&amp;que);  <span class="hljs-comment">// 进行基数排序</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排序后序列：\n&quot;</span>);<br>    print(&amp;que);  <span class="hljs-comment">// 打印排序后的队列</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>待排序列为n个记录，d个关键字，关键字的取值范围为 r，其中，一趟分配时间复杂度为 O(n)，一趟收集时间复杂度为O(rd)，共进行 d 趟分配和收集，所以链式基数排序的时间复杂度为 O( d·(n+rd) ) 。</p><p><strong>空间复杂度：</strong></p><p>O(rd + n )，因为一个桶本质是一个链式队列，一共 r 个桶，每个队列有队头和队尾两个指针，就是2 rd 个队列指针。又原来的待排序列是一个单链表，那么需要 n 个next指针。</p><p>执行结果：</p><p><img src="/../img/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="基数排序"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="/2023/11/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2023/11/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>以下代码：首先统计了输入字符序列中每个字符出现的次数，然后基于这些统计结果构建了哈夫曼树，并生成了相应的哈夫曼编码和权重</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CHARACTERS 256</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">char</span> data; <span class="hljs-comment">// 节点存储的数据</span><br>    <span class="hljs-type">int</span> frequency; <span class="hljs-comment">// 节点的频率</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>, * <span class="hljs-title">right</span>;</span> <span class="hljs-comment">// 左子节点和右子节点的指针</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span> &#123;</span><br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">// MinTree中存储的节点数</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// MinTree的容量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>** <span class="hljs-title">array</span>;</span> <span class="hljs-comment">// 存储节点的指针数组</span><br>&#125;;<br><br><span class="hljs-comment">// 创建一个新的节点</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data, <span class="hljs-type">int</span> frequency)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <span class="hljs-comment">// 为节点分配内存空间</span><br>    node-&gt;left = node-&gt;right = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 初始化左子节点和右子节点指针为空</span><br>    node-&gt;data = data; <span class="hljs-comment">// 设置节点存储的数据</span><br>    node-&gt;frequency = frequency; <span class="hljs-comment">// 设置节点的频率</span><br>    <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// 返回创建的节点指针</span><br>&#125;<br><br><span class="hljs-comment">// 创建一个新的MinTree</span><br><span class="hljs-comment">// capacity: MinTree的容量</span><br><span class="hljs-keyword">struct</span> MinTree* <span class="hljs-title function_">createMinTree</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span>* <span class="hljs-title">minTree</span> =</span> (<span class="hljs-keyword">struct</span> MinTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> MinTree)); <span class="hljs-comment">// 为MinTree分配内存空间</span><br>    minTree-&gt;size = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化MinTree的节点数为0</span><br>    minTree-&gt;capacity = capacity; <span class="hljs-comment">// 设置MinTree的容量</span><br>    minTree-&gt;<span class="hljs-built_in">array</span> = (<span class="hljs-keyword">struct</span> Node**)<span class="hljs-built_in">malloc</span>(capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node*)); <span class="hljs-comment">// 为存储节点的指针数组分配内存空间</span><br>    <span class="hljs-keyword">return</span> minTree; <span class="hljs-comment">// 返回创建的MinTree的指针</span><br>&#125;<br><br><span class="hljs-comment">// 交换两个节点的指针</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swapNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node** a, <span class="hljs-keyword">struct</span> Node** b)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">t</span> =</span> *a; <span class="hljs-comment">// 临时变量保存第一个节点的指针指向的节点</span><br>    *a = *b; <span class="hljs-comment">// 将第二个节点的指针赋值给第一个节点的指针</span><br>    *b = t; <span class="hljs-comment">// 将临时变量保存的第一个节点的指针赋值给第二个节点的指针</span><br>&#125;<br><br><span class="hljs-comment">// 将最小树中以指定索引为根节点的子树变成最小堆</span><br><span class="hljs-comment">// minTree: 最小树的指针</span><br><span class="hljs-comment">// idx: 子树的根节点索引</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minTreeify</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-type">int</span> smallest = idx; <span class="hljs-comment">// 假设根节点的值最小</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子节点的索引</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>; <span class="hljs-comment">// 右子节点的索引</span><br>    <span class="hljs-comment">// 如果左子节点存在且频率比当前最小节点小，则更新最小节点索引</span><br>    <span class="hljs-keyword">if</span> (left &lt; minTree-&gt;size &amp;&amp; minTree-&gt;<span class="hljs-built_in">array</span>[left]-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[smallest]-&gt;frequency)<br>        smallest = left;<br>    <span class="hljs-comment">// 如果右子节点存在且频率比当前最小节点小，则更新最小节点索引</span><br>    <span class="hljs-keyword">if</span> (right &lt; minTree-&gt;size &amp;&amp; minTree-&gt;<span class="hljs-built_in">array</span>[right]-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[smallest]-&gt;frequency)<br>        smallest = right;<br>    <span class="hljs-comment">// 如果最小节点不是根节点，则交换最小节点和根节点，并对交换后的子树进行调整</span><br>    <span class="hljs-keyword">if</span> (smallest != idx) &#123;<br>        swapNode(&amp;minTree-&gt;<span class="hljs-built_in">array</span>[smallest], &amp;minTree-&gt;<span class="hljs-built_in">array</span>[idx]);<br>        minTreeify(minTree, smallest);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断MinTree是否只有一个节点</span><br><span class="hljs-comment">// minTree: MinTree指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isSizeOne</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree)</span> &#123;<br>    <span class="hljs-keyword">return</span> (minTree-&gt;size == <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 从MinTree中提取最小节点</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">extractMin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">temp</span> =</span> minTree-&gt;<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 保存需要提取的最小节点</span><br>    minTree-&gt;<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = minTree-&gt;<span class="hljs-built_in">array</span>[minTree-&gt;size - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 将最后一个节点移到根节点位置</span><br>    --minTree-&gt;size; <span class="hljs-comment">// MinTree大小减1</span><br>    minTreeify(minTree, <span class="hljs-number">0</span>); <span class="hljs-comment">// 重新调整MinTree的堆序性质</span><br>    <span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// 返回被提取的最小节点</span><br>&#125;<br><br><span class="hljs-comment">// 向MinTree中插入一个节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertMinTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree, <span class="hljs-keyword">struct</span> Node* node)</span> &#123;<br>    ++minTree-&gt;size; <span class="hljs-comment">// MinTree大小增加1</span><br>    <span class="hljs-type">int</span> i = minTree-&gt;size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &amp;&amp; node-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]-&gt;frequency) &#123;<br>        minTree-&gt;<span class="hljs-built_in">array</span>[i] = minTree-&gt;<span class="hljs-built_in">array</span>[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]; <span class="hljs-comment">// 将父节点移到当前位置</span><br>        i = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新位置到父节点的位置</span><br>    &#125;<br>    minTree-&gt;<span class="hljs-built_in">array</span>[i] = node; <span class="hljs-comment">// 将新节点插入到对应位置</span><br>&#125;<br><br><span class="hljs-comment">// 以给定的数据和频率构建哈夫曼树</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">char</span> data[], <span class="hljs-type">int</span> frequency[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>, * <span class="hljs-title">right</span>, * <span class="hljs-title">top</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span>* <span class="hljs-title">minTree</span> =</span> createMinTree(size); <span class="hljs-comment">// 创建一个最小堆，用于构建哈夫曼树</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequency[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            minTree-&gt;<span class="hljs-built_in">array</span>[minTree-&gt;size++] = newNode(data[i], frequency[i]); <span class="hljs-comment">// 将节点插入最小堆中</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最小堆化，使堆顶元素为最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = minTree-&gt;size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        minTreeify(minTree, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过不断取出堆顶和次堆顶的方式，构建哈夫曼树</span><br>    <span class="hljs-keyword">while</span> (!isSizeOne(minTree)) &#123;<br>        left = extractMin(minTree); <span class="hljs-comment">// 取出最小的节点作为左子树</span><br>        right = extractMin(minTree); <span class="hljs-comment">// 取出次小的节点作为右子树</span><br>        top = newNode(<span class="hljs-string">&#x27;$&#x27;</span>, left-&gt;frequency + right-&gt;frequency); <span class="hljs-comment">// 创建一个新的节点作为父节点</span><br>        top-&gt;left = left; <span class="hljs-comment">// 左子节点</span><br>        top-&gt;right = right; <span class="hljs-comment">// 右子节点</span><br>        insertMinTree(minTree, top); <span class="hljs-comment">// 将新节点插入最小堆中</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extractMin(minTree); <span class="hljs-comment">// 最后返回哈夫曼树的根节点</span><br>&#125;<br><br><span class="hljs-comment">// 递归打印哈夫曼编码</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printCodes</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* root, <span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> top)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于控制输出格式</span><br>    <span class="hljs-keyword">if</span> (!(root-&gt;left) &amp;&amp; !(root-&gt;right)) &#123; <span class="hljs-comment">// 当前节点为叶子节点</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Character: %c, Weight: %u, Huffman Code: &quot;</span>, root-&gt;data, root-&gt;frequency); <span class="hljs-comment">// 输出字符、频率和编码</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; ++i) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[i]); <span class="hljs-comment">// 遍历路径数组，打印编码</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (first) &#123; <span class="hljs-comment">// 第一次打印该编码时，在最后不需要加换行符</span><br>            first = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left) &#123; <span class="hljs-comment">// 遍历左子树，将路径加入数组，并递归遍历子树</span><br>        arr[top] = <span class="hljs-number">0</span>;<br>        printCodes(root-&gt;left, arr, top + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;right) &#123; <span class="hljs-comment">// 遍历右子树，将路径加入数组，并递归遍历子树</span><br>        arr[top] = <span class="hljs-number">1</span>;<br>        printCodes(root-&gt;right, arr, top + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> characters[MAX_CHARACTERS];<br>    <span class="hljs-type">int</span> frequencies[MAX_CHARACTERS] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of characters: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter %d characters: &quot;</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;characters[i]);<br>        frequencies[(<span class="hljs-type">int</span>)characters[i]]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> L_chars = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CHARACTERS; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequencies[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            L_chars++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">char</span> L_characters[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> L_frequencies[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CHARACTERS; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequencies[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            L_characters[index] = (<span class="hljs-type">char</span>)i;<br>            L_frequencies[index] = frequencies[i];<br>            index++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">root</span> =</span> buildHuffmanTree(L_characters, L_frequencies, L_chars);<br><br>    <span class="hljs-type">int</span> arr[MAX_CHARACTERS], top_index = <span class="hljs-number">0</span>;<br>    printCodes(root, arr, top_index);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>共享栈</title>
    <link href="/2023/10/23/%E5%85%B1%E4%BA%AB%E6%A0%88/"/>
    <url>/2023/10/23/%E5%85%B1%E4%BA%AB%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>共享栈是一种特殊的栈结构，它允许两个栈共享同一段物理内存区域。共享栈有两个栈顶指针，分别称为top 1和top 2，它们分别指向两个栈的栈顶元素。在共享栈中，两个栈可以分别从两端向中间生长，当它们的栈顶指针相遇时，表示共享栈已满。</p><p>下面是共享栈的基本操作：</p><ol><li>初始化（Init）：创建一个空的共享栈，并初始化top 1和top 2指针为-1，表示两个栈为空。</li><li>入栈（Push）：<ul><li>当要插入元素到栈1时，先检查top 1是否小于top 2-1，如果是，则将元素插入top 1位置，top 1加1。</li><li>当要插入元素到栈2时，先检查top 1是否小于top 2-1，如果是，则将元素插入top 2位置，top 2减1。</li></ul></li><li>出栈（Pop）：<ul><li>当要从栈1中出栈时，首先检查top 1是否不等于-1，如果是，则将top 1位置的元素弹出，并将top 1减1。</li><li>当要从栈2中出栈时，首先检查top 2是否不等于-1，如果是，则将top 2位置的元素弹出，并将top 2加1。</li></ul></li><li>判空（Is Empty）：检查top 1和top 2是否都为-1，如果是，则共享栈为空。</li><li>判满（Is Full）：检查top 1和top 2是否相差为1，如果是，则共享栈已满。</li><li>获取栈顶元素（Top）：<ul><li>当要获取栈1的栈顶元素时，首先检查top 1是否不等于-1，如果是，则返回top 1位置的元素。</li><li>当要获取栈2的栈顶元素时，首先检查top 2是否不等于-1，如果是，则返回top 2位置的元素。</li></ul></li></ol><p>以下是共享栈的伪代码实现，包括初始化、入栈、出栈和获取栈顶元素等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType data[MAX_SIZE];<br>    <span class="hljs-type">int</span> top1;  <span class="hljs-comment">// 第一个栈的栈顶指针</span><br>    <span class="hljs-type">int</span> top2;  <span class="hljs-comment">// 第二个栈的栈顶指针</span><br>&#125; SharedStack;<br><span class="hljs-comment">//栈满条件：top1 + 1 = top2</span><br><br><span class="hljs-comment">// 初始化共享栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initSharedStack</span><span class="hljs-params">(SharedStack &amp;S)</span> </span><br><span class="hljs-function"></span>&#123;<br>    S.top1 = <span class="hljs-number">-1</span>;<br>    S.top2 = MAX_SIZE;<br>&#125;<br><br><span class="hljs-comment">// 第一个栈的入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pushStack1</span><span class="hljs-params">(SharedStack &amp;S, ElemType x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top1 + <span class="hljs-number">1</span> &lt; S.top2) <br>    &#123;<span class="hljs-comment">//指针先加1，再入栈</span><br>        S.top1++;<br>        S.data[S.top1] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已满，无法进行入栈操作\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第一个栈的出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popStack1</span><span class="hljs-params">(SharedStack &amp;S, ElemType &amp;x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top1 &gt;= <span class="hljs-number">0</span>) <br>    &#123;<span class="hljs-comment">//先出栈，指针再减1</span><br>        x = S.data[S.top1];<br>        S.top1--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示栈为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二个栈的入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pushStack2</span><span class="hljs-params">(SharedStack &amp;S, ElemType x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top2 - <span class="hljs-number">1</span> &gt; S.top1) <br>    &#123;<span class="hljs-comment">//指针先减1，再入栈</span><br>        S.top2--;<br>        S.data[S.top2] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已满，无法进行入栈操作\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二个栈的出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popStack2</span><span class="hljs-params">(SharedStack &amp;S, ElemType &amp;x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top2 &lt; MAX_SIZE) <br>    &#123;<span class="hljs-comment">//先入栈，指针再加1</span><br>        x = S.data[S.top2];<br>        S.top2++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已空，无法进行出栈操作\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示栈为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getTopElement</span><span class="hljs-params">(SharedStack S, ElemType &amp;x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top1 &gt;= <span class="hljs-number">0</span>) <br>    &#123;<br>       <span class="hljs-keyword">return</span> S.data[S.top1];<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S.top2 &lt; MAX_SIZE) <br>    &#123;<br>        <span class="hljs-keyword">return</span> S.data[S.top2];<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已空，无栈顶元素\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示栈为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转换函数</title>
    <link href="/2022/11/15/2022212741%E6%9D%8E%E6%98%8E/"/>
    <url>/2022/11/15/2022212741%E6%9D%8E%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h5 id="实现十进制数字到任意进制的转换函数"><a href="#实现十进制数字到任意进制的转换函数" class="headerlink" title="实现十进制数字到任意进制的转换函数:"></a>实现十进制数字到任意进制的转换函数:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">baseConverter</span><span class="hljs-params">(<span class="hljs-type">int</span> dec,<span class="hljs-type">int</span> base)</span>;<br><span class="hljs-comment">//其中base为转换的基数</span><br><span class="hljs-comment">//示例：</span><br>--&gt;input   :<span class="hljs-number">250</span>, <span class="hljs-number">16</span><br>--&gt;output  :FA<br></code></pre></td></tr></table></figure><h4 id="查资料："><a href="#查资料：" class="headerlink" title="查资料："></a>查资料：</h4><p>基数：在一种数制中，只能使用一组固定的数字来表示数的大小，这组固定的数字的个数就称为该计数制的基数（Base）。例如十进制的基数为10，二进制的基数为2等。</p><p>权：又称为位权或权值，即每一个数位都有一个固定的基值与之相对应，称之为权。如十进制的个位对应的权值为1（100），十位对应的权值为10（101），百位对应的权值为100（102）。对于一个 M 进制的数来说，小数点左边各位上对应的权值从右到左分别为基数的0次方、基数的1次方、基数的2次方等，对于小数点右边各位上对应的权值从左到右分别为基数的-1次方、基数的-2次方等。<br>二进制、八进制、十六进制向十进制转换：按权展开相加。<br>十进制转换成二进制、八进制、十六进制：整数部分除以基数取余数（取余的方向为从后向前）；小数部分乘以基数取整数（取整的方向为从前向后）。<br>二进制、八进制、十六进制相互转换：先转换成十进制再转换成其他进制；或者按照其对应关系进行转换（三位二进制数对应一位八进制数，四位二进制数对应一位十六进制数）。</p><h4 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h4><p>十六进制是由 0~F 这一组固定的数字来表示，所以釆用字符数组进行存储。<br>在执行程序时可以输入多组数据来验证程序的正确性</p><h4 id="程序源码："><a href="#程序源码：" class="headerlink" title="程序源码："></a>程序源码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">baseConverter</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j, num[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> k[] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span> &#125;;<br><span class="hljs-keyword">do</span> &#123;<br>i++;<br>num[i] = a % b;<br>a /= b;<br>&#125; <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (j = i; j &gt;= <span class="hljs-number">1</span>; j--)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, k[num[j]]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);<br>baseConverter(i,j);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行实例："><a href="#运行实例：" class="headerlink" title="运行实例："></a>运行实例：</h4><p><img src="/../img/1.png"></p><p><img src="/../img/2.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/13/hello-world/"/>
    <url>/2022/10/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
