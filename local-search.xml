<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python（一）</title>
    <link href="/2024/04/17/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/04/17/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Python语言基础-流程控制"><a href="#Python语言基础-流程控制" class="headerlink" title="Python语言基础-流程控制"></a>Python语言基础-流程控制</h2><p>Python语言的基础流程控制包括条件语句（if语句）、循环语句（for循环和while循环）以及跳转语句（break、continue和return语句）。即：</p><ol><li><strong>条件语句（if语句）</strong>：if语句用于根据条件执行代码块。它可以包含一个或多个条件以及相应的代码块。Python使用缩进来表示代码块。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition1:<br>    <span class="hljs-comment"># 如果条件1为真，则执行这里的代码</span><br><span class="hljs-keyword">elif</span> condition2:<br>    <span class="hljs-comment"># 如果条件2为真，则执行这里的代码</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 如果以上条件都不满足，则执行这里的代码</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>循环语句</strong>：</li></ol><ul><li><strong>for循环</strong>：用于迭代可迭代对象（如列表、元组、字典等）中的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable:<br>    <span class="hljs-comment"># 对每个元素执行的代码</span><br></code></pre></td></tr></table></figure><ul><li><strong>while循环</strong>：在条件为真时重复执行代码块，直到条件为假为止。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> condition:<br>    <span class="hljs-comment"># 在条件为真时执行的代码</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>跳转语句</strong>：<ul><li><strong>break语句</strong>：用于跳出循环，即使循环条件没有变为False。</li><li><strong>continue语句</strong>：用于跳过循环体中的剩余代码，继续下一次循环。</li><li><strong>return语句</strong>：用于从函数中返回值，并结束函数的执行。</li></ul></li></ol><p>这些是Python中基础的流程控制结构，它们可以帮助你编写更加灵活和功能强大的程序。</p><p>some  demos：</p><p>1.计算平均成绩代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">total=<span class="hljs-number">0</span>;ave=<span class="hljs-number">0</span>;count=<span class="hljs-number">0</span>;<br>score=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入学生英语成绩：&quot;</span>))<br><span class="hljs-keyword">while</span> score != -<span class="hljs-number">1</span>:<br>    total=total+score<br>    count=count+<span class="hljs-number">1</span><br>    score=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入学生英语成绩：&quot;</span>))<br><span class="hljs-keyword">if</span> count != <span class="hljs-number">0</span>:<br>    average = total / count  <span class="hljs-comment"># 如果count为0时，这里会导致ZeroDivisionError，可以加上判断条件避免除零错误-1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;录入学生英语成绩 %d 份，学生英语总成绩 %d，平均成绩 %4.2f.&quot;</span> % (count, total, average))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有录入学生英语成绩。&quot;</span>)<br></code></pre></td></tr></table></figure><p>代码逻辑：首先输入第一个学生的成绩然后进入while循环，输入完所有数据后输入-1跳出循环，计算并输出结果</p><p>优化：average &#x3D; total &#x2F; count  后加上判断条件避免除零错误-1 </p><p>2.列表输出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">universities = [<span class="hljs-string">&#x27;哈佛大学&#x27;</span>,<span class="hljs-string">&#x27;斯坦福大学&#x27;</span>,<span class="hljs-string">&#x27;剑桥大学&#x27;</span>,<span class="hljs-string">&#x27;麻省理工学院&#x27;</span>,<span class="hljs-string">&#x27;加州大学-伯克利&#x27;</span>,<span class="hljs-string">&#x27;普林\</span><br><span class="hljs-string">斯顿大学&#x27;</span>,<span class="hljs-string">&#x27;牛津大学&#x27;</span>,<span class="hljs-string">&#x27;哥伦比亚大学&#x27;</span>,<span class="hljs-string">&#x27;加州理工学院&#x27;</span>,<span class="hljs-string">&#x27;芝加哥大学&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2017《Times》世界大学排名前3的大学是：&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;.&quot;</span>,universities[i])<br></code></pre></td></tr></table></figure><p>代码逻辑：首先定义了一个包含了若干大学名称的列表，然后通过一个循环打印出了这个列表中前6个元素（大学名称），每个元素前面带有相应的排名</p><p>3.猜数字大小代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br>key = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------猜数字游戏开始！------&#x27;</span>)<br>count = <span class="hljs-number">0</span><br>x= <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入数字：&#x27;</span>))<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 检查输入是否为数字</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x.isdigit():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请输入一个有效的数字！&#x27;</span>)<br>        <span class="hljs-keyword">continue</span><br>    count = count + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> x &gt; key:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您猜的数字大了！&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> x &lt; key:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您猜的数字小了！&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;恭喜您，猜对了！&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> count &gt;= <span class="hljs-number">5</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;很遗憾，您没猜中！生成数字是：%d.&#x27;</span>%key)<br>        <span class="hljs-keyword">break</span><br>    x=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入数字：&quot;</span>))<br></code></pre></td></tr></table></figure><p>4.斐波那契数列代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">n1=<span class="hljs-number">1</span><br>n2=<span class="hljs-number">1</span><br>count=<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;斐波那契数列前10项为:&quot;</span>,end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(n1,n2,end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span> count&gt;=<span class="hljs-number">10</span>:<br>     <span class="hljs-keyword">break</span><br>    nth=n1+n2<br>    <span class="hljs-built_in">print</span>(nth,end=<span class="hljs-string">&quot; &quot;</span>)<br>    n1=n2<br>    n2=nth<br>    count+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>代码逻辑：首先定义了 n1&#x3D;1、n2&#x3D;1、count&#x3D;2，然后使用 print() 函数输出前两项的值，并设置 end&#x3D;” “，使得输出不换行而是在同一行显示。接着进入一个 while 的循环，每次循环计算下一个斐波那契数，并输出该数，然后更新 n1、n2 的值，同时 count 加一，直到 count 达到 10 时退出循环. </p><p> OR:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    fib_seq = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]     <span class="hljs-comment"># 初始化斐波那契数列的前两个数字</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):      <span class="hljs-comment"># 生成斐波那契数列的第三个数字开始的前 n 个数字</span><br>        fib_seq.append(fib_seq[-<span class="hljs-number">1</span>] + fib_seq[-<span class="hljs-number">2</span>])      <span class="hljs-comment"># 计算下一个斐波那契数并添加到数列中</span><br>    <span class="hljs-keyword">return</span> fib_seq<br><br>Fib_seq = fibonacci(<span class="hljs-number">50</span>)     <span class="hljs-comment"># 调用 Fibonacci 函数生成斐波那契数列的前 50 位数字</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;斐波那契数列的前 50 位数字：&quot;</span>, Fib_seq)<br></code></pre></td></tr></table></figure><p>5.模拟自动饮料机代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br>投币 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请投币：&quot;</span>))<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span> 投币 == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;叮咚：设备停止工作！&quot;</span>)<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">elif</span> 投币 == <span class="hljs-number">1</span>:<br>        叮咚 = <span class="hljs-string">&quot;冰露纯净水&quot;</span><br>    <span class="hljs-keyword">elif</span> 投币 == <span class="hljs-number">2</span>:<br>        叮咚 = <span class="hljs-string">&quot;农夫山泉矿泉水&quot;</span><br>    <span class="hljs-keyword">elif</span> 投币 == <span class="hljs-number">3</span>:<br>        叮咚 = <span class="hljs-string">&quot;冰红茶&quot;</span><br>    <span class="hljs-keyword">elif</span> 投币 == <span class="hljs-number">4</span>:<br>        叮咚 = <span class="hljs-string">&quot;脉动&quot;</span><br>    <span class="hljs-keyword">elif</span> 投币 == <span class="hljs-number">5</span>:<br>        叮咚 = <span class="hljs-string">&quot;红牛&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        叮咚 = <span class="hljs-string">&quot;投币错误！请重新投币...&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;叮咚：&quot;</span>, 叮咚)<br>    投币 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请投币：&quot;</span>))<br></code></pre></td></tr></table></figure><p>代码逻辑：使用int(input(“请投币：”))语句，提示用户输入投币金额，并将输入的字符串转换为整数。使用while True:建立了一个无限循环，直到用户选择停止购买或投币金额为0时才会退出循环。 根据用户输入的投币金额，使用if-elif-else语句进行条件判断，确定对应的饮料，并输出相应信息。 </p><p>6.数列求和代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">1</span>; n = <span class="hljs-number">10</span>; <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt;= n:<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>        i = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>    i = i + <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sum=&quot;</span>,<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure><p>代码逻辑：计算从1到10（包括1和10）之间所有偶数的和。continue 语句是关键，它确保了只有偶数会被加到 sum 变量中，而奇数则会被跳过。</p><p>优化：①变量名 sum 覆盖了 Python 内置函数 sum()，最好避免使用内置函数名作为变量名。</p><p>②i 的更新在两个地方出现了，可以简化为循环的 for 形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">10</span><br>total_sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):<br>    total_sum += i<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sum =&quot;</span>, total_sum) <br></code></pre></td></tr></table></figure><p>7.输出对角线元素为1 的4 行4 列矩阵代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">if</span> i==j <span class="hljs-keyword">or</span> i+j==<span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>,end=<span class="hljs-string">&#x27; &#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0&quot;</span>,end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p>代码逻辑；嵌套循环，在内层循环中，通过判断条件来确定当前位置应该打印1还是0：若当前位置位于主对角线（i &#x3D;&#x3D; j）或副对角线（i + j &#x3D;&#x3D; 5），则打印1。否则，打印0。 </p><p>8.通过for 循环打印99 乘法表代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>):<br>        total=i*j<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;j&#125;</span>*<span class="hljs-subst">&#123;i&#125;</span>=<span class="hljs-subst">&#123;i*j&#125;</span>&quot;</span>,end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p>代码逻辑：使用两层嵌套的 for 循环。外层循环控制行数（从1到9），内层循环控制每行中的列数（也是从1到行号）。最后使用 f-string 格式化字符串打印结果。</p><p>11.打印如下所示的菱形代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打印上半部分</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):  <span class="hljs-comment"># 控制行数，上半部分有4行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span> * (<span class="hljs-number">4</span> - i) + <span class="hljs-string">&quot;*&quot;</span> * (<span class="hljs-number">2</span> * i - <span class="hljs-number">1</span>))  <span class="hljs-comment"># 打印空格和星号，构成菱形的每一行</span><br><br><span class="hljs-comment"># 打印下半部分</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 控制行数，下半部分有3行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span> * (<span class="hljs-number">4</span> - i) + <span class="hljs-string">&quot;*&quot;</span> * (<span class="hljs-number">2</span> * i - <span class="hljs-number">1</span>))  <span class="hljs-comment"># 打印空格和星号，构成菱形的每一行</span><br></code></pre></td></tr></table></figure><p>代码逻辑：</p><p>上半部分：使用for循环迭代从1到4的范围，控制菱形上半部分的行数。在每一行中，通过”  “<em>(4-i)打印一定数量的空格，使得菱形居中对齐。使用 “</em>“ * (2 * i - 1) 打印一定数量的星号，构成菱形上半部分的每一行。</p><p>下半部分：使用 for 循环迭代从3到1的范围（步长为-1），控制菱形下半部分的行数。在每一行中，同样通过 “ “ * (4 - i) 打印一定数量的空格，使得菱形居中对齐。使用 “*” * (2 * i - 1) 打印一定数量的星号，构成菱形下半部分的每一行。</p><p>结果：</p><p><img src="/../img/wps25.jpg" alt="img"> </p><p>小记：打牢基础！！！</p><p>Python 的流程控制对于控制程序执行流程非常重要。在学习 Python 的流程控制时，对于条件语句 (if-elif-else)、循环语句 (for、while)、以及控制语句 (break、continue) 等基本知识的掌握十分重要。在编写代码时，合理运用这些流程控制结构可以让代码更加清晰、简洁，同时实现不同的逻辑要求。同时，准确理解语句块的缩进在 Python 中尤为重要，因为它决定了哪些语句属于同一个语句块，也能让我们更好了解代码逻辑。同时，在学习这一内容时，我认为对于基础语句的规则和使用场景的理解需要着重学习。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python（二）</title>
    <link href="/2024/04/17/%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/04/17/%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="组合数据类型（一）"><a href="#组合数据类型（一）" class="headerlink" title="组合数据类型（一）"></a>组合数据类型（一）</h2><ol><li><strong>字符串的相关操作函数包括但不限于</strong>：</li></ol><ul><li><code>len(string)</code>: 返回字符串的长度。</li><li><code>string[index]</code>: 获取字符串中索引为index的字符。</li><li><code>string[start:end:step]</code>: 切片操作，获取字符串的子串。</li><li><code>string.count(substring)</code>: 统计子串在字符串中出现的次数。</li><li><code>string.find(substring)</code>: 查找子串在字符串中第一次出现的位置。</li><li><code>string.replace(old, new)</code>: 替换字符串中的部分内容。</li><li><code>string.upper()</code>, <code>string.lower()</code>: 将字符串转换为全大写或全小写。</li><li><code>string.strip()</code>, <code>string.lstrip()</code>, <code>string.rstrip()</code>: 去除字符串两端或指定端的空白字符。</li></ul><ol start="2"><li><strong>列表相关操作函数包括但不限于</strong>：</li></ol><ul><li><code>len(list)</code>: 返回列表的长度。</li><li><code>list.append(element)</code>: 在列表末尾添加一个元素。</li><li><code>list.extend(iterable)</code>: 在列表末尾一次性追加另一个可迭代对象的所有元素。</li><li><code>list.insert(index, element)</code>: 在指定位置插入一个元素。</li><li><code>list.remove(element)</code>: 移除列表中第一个匹配的元素。</li><li><code>list.pop([index])</code>: 移除并返回指定位置的元素，默认是移除并返回最后一个元素。</li><li><code>list.index(element)</code>: 返回列表中第一个匹配元素的索引。</li><li><code>list.count(element)</code>: 返回元素在列表中出现的次数。</li><li><code>list.sort()</code>: 对列表进行排序。</li><li><code>list.reverse()</code>: 将列表中的元素倒序排列。</li><li><code>list.copy()</code>: 返回列表的浅复制。</li></ul><ol start="3"><li><strong>元组相关操作函数</strong>：</li></ol><ul><li><code>len(tuple)</code>: 返回元组的长度。</li><li><code>tuple.index(element)</code>: 返回元组中第一个匹配元素的索引。</li><li><code>tuple.count(element)</code>: 返回元素在元组中出现的次数。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基数排序(多关键字排序)</title>
    <link href="/2023/12/10/%E9%93%BE%E5%BC%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/12/10/%E9%93%BE%E5%BC%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>是一种借助“多关键字排序”的思想来实现“单关键字排序”的内部排序算法。可以将每个关键字 K 看成由四个单关键字组成，即 K&#x3D; k 1,k 2,k 3,k 4 每个关键字的取值范围为 0≤k i≤9，所以每个关键字可取值的数目为 10。通常将关键字取值的数目称为基数，用 r 表示，下例中 r &#x3D;10。</p><p>链式基数排序（Radix Sort）是一种基于数位的排序算法。(这里使用LSD法进行排序)具体实现方法如下：</p><ol><li>取得链表中的最大数，并取得位数</li><li>从最低位开始，依次对每个数位进行排序，将排序结果存储到桶(辅助空间)中</li><li>将桶(辅助空间)中的结果存回原链表中</li><li>重复步骤2-3，直到最高位排序完毕</li></ol><p>以下是实现20个四位数的链式基数排序的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 定义链表结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125; Node;<br><span class="hljs-comment">// 定义队列结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span></span><br><span class="hljs-class">&#123;</span><br>    Node* front;  <span class="hljs-comment">// 队列前端</span><br>    Node* rear;   <span class="hljs-comment">// 队列后端</span><br>&#125; Queue;<br><br>Queue <span class="hljs-built_in">queue</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">// 10 个队列，用于分配和收集数据</span><br><span class="hljs-type">int</span> divisior = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 用于按位取数的除数，初始为1</span><br><br><span class="hljs-comment">// 初始化队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">initQueue</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    Node* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        p-&gt;data = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化结点数据为0</span><br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        (*que).front = p;<br>        (*que).rear = p;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;node apply error!\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 入队操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Queue* que, <span class="hljs-type">int</span> e)</span><br>&#123;<br>    Node* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        p-&gt;data = e;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        (*que).rear-&gt;next = p;  <span class="hljs-comment">// 将新结点插入队尾</span><br>        (*que).rear = p;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;node apply error!\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 清空队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    (*que).front-&gt;next = <span class="hljs-literal">NULL</span>;<br>    (*que).rear = (*que).front;<br>&#125;<br><br><span class="hljs-comment">// 获取最大数的位数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxBit</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    Node* p = (*que).front-&gt;next;<br>    <span class="hljs-type">int</span> maxData = p-&gt;data;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxData &lt; p-&gt;data) &#123;<br>            maxData = p-&gt;data;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (maxData &gt; <span class="hljs-number">0</span>) &#123;<br>        maxData /= <span class="hljs-number">10</span>;<br>        b++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-comment">// 根据当前位数获取关键字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getKey</span><span class="hljs-params">(Node* q)</span><br>&#123;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    k = ((*q).data / divisior) % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><br><span class="hljs-comment">// 分配数据到各个队列中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">distributeRadix</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        initQueue(&amp;<span class="hljs-built_in">queue</span>[i]);  <span class="hljs-comment">// 初始化10个队列</span><br>    &#125;<br>    Node* p = (*que).front-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">int</span> k = getKey(p); <br>        <span class="hljs-built_in">queue</span>[k].rear-&gt;next = p;  <span class="hljs-comment">// 将当前结点放入对应队列中</span><br>        <span class="hljs-built_in">queue</span>[k].rear = p;  <span class="hljs-comment">// 更新队列尾结点</span><br>        p = p-&gt;next;<br>        <span class="hljs-built_in">queue</span>[k].rear-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    clear(que);  <span class="hljs-comment">// 清空原队列</span><br>&#125;<br><br><span class="hljs-comment">// 将数据收集到原队列中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">collectRadix</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span>; index++) &#123;<br>        <span class="hljs-keyword">if</span> (&amp;<span class="hljs-built_in">queue</span>[index].front-&gt;next-&gt;data != <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">// 找到第一个非空队列</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    Node* p = <span class="hljs-built_in">queue</span>[index].front-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        (*que).rear-&gt;next = p;  <span class="hljs-comment">// 将队列中的数据接入原队列</span><br>        (*que).rear = p; <br>        p = p-&gt;next;<br>        (*que).rear-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (index++; index &lt; <span class="hljs-number">10</span>; index++) &#123;<br>        Node* q = <span class="hljs-built_in">queue</span>[index].front-&gt;next; <br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            (*que).rear-&gt;next = q; <br>            (*que).rear = q;<br>            q = q-&gt;next;<br>            (*que).rear-&gt;next = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        clear(&amp;<span class="hljs-built_in">queue</span>[i]);  <span class="hljs-comment">// 清空各个队列</span><br>    &#125;<br>    divisior *= <span class="hljs-number">10</span>;  <span class="hljs-comment">// 更新除数</span><br>&#125;<br><br><span class="hljs-comment">// 基数排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">radix</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    <span class="hljs-type">int</span> b = maxBit(que);  <span class="hljs-comment">// 获取最大位数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br>        distributeRadix(que);  <span class="hljs-comment">// 按当前位数分配到各个队列</span><br>        collectRadix(que);  <span class="hljs-comment">// 将数据收集到原队列</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Queue* que)</span><br>&#123;<br>    Node* p = (*que).front-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    Queue que;<br>    initQueue(&amp;que);<br>    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">1234</span>, <span class="hljs-number">5678</span>, <span class="hljs-number">9101</span>, <span class="hljs-number">2345</span>, <span class="hljs-number">6789</span>, <span class="hljs-number">1011</span>, <span class="hljs-number">1213</span>, <span class="hljs-number">1415</span>, <span class="hljs-number">1617</span>, <span class="hljs-number">1819</span>,<br>        <span class="hljs-number">2021</span>, <span class="hljs-number">2223</span>, <span class="hljs-number">2425</span>, <span class="hljs-number">2627</span>, <span class="hljs-number">2829</span>,<span class="hljs-number">3032</span>, <span class="hljs-number">3233</span>, <span class="hljs-number">3435</span>, <span class="hljs-number">3637</span>, <span class="hljs-number">3839</span> &#125;;<br>    <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        push(&amp;que, arr[i]);  <span class="hljs-comment">// 将数据入队</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排序前序列：\n&quot;</span>);<br>    print(&amp;que);<br>    radix(&amp;que);  <span class="hljs-comment">// 进行基数排序</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排序后序列：\n&quot;</span>);<br>    print(&amp;que);  <span class="hljs-comment">// 打印排序后的队列</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>待排序列为n个记录，d个关键字，关键字的取值范围为 r，其中，一趟分配时间复杂度为 O(n)，一趟收集时间复杂度为O(rd)，共进行 d 趟分配和收集，所以链式基数排序的时间复杂度为 O( d·(n+rd) ) 。</p><p><strong>空间复杂度：</strong></p><p>O(rd + n )，因为一个桶本质是一个链式队列，一共 r 个桶，每个队列有队头和队尾两个指针，就是2 rd 个队列指针。又原来的待排序列是一个单链表，那么需要 n 个next指针。</p><p>执行结果：</p><p><img src="/../img/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="基数排序"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="/2023/11/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2023/11/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>以下代码：首先统计了输入字符序列中每个字符出现的次数，然后基于这些统计结果构建了哈夫曼树，并生成了相应的哈夫曼编码和权重</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CHARACTERS 256</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">char</span> data; <span class="hljs-comment">// 节点存储的数据</span><br>    <span class="hljs-type">int</span> frequency; <span class="hljs-comment">// 节点的频率</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>, * <span class="hljs-title">right</span>;</span> <span class="hljs-comment">// 左子节点和右子节点的指针</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span> &#123;</span><br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">// MinTree中存储的节点数</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// MinTree的容量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>** <span class="hljs-title">array</span>;</span> <span class="hljs-comment">// 存储节点的指针数组</span><br>&#125;;<br><br><span class="hljs-comment">// 创建一个新的节点</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data, <span class="hljs-type">int</span> frequency)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <span class="hljs-comment">// 为节点分配内存空间</span><br>    node-&gt;left = node-&gt;right = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 初始化左子节点和右子节点指针为空</span><br>    node-&gt;data = data; <span class="hljs-comment">// 设置节点存储的数据</span><br>    node-&gt;frequency = frequency; <span class="hljs-comment">// 设置节点的频率</span><br>    <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// 返回创建的节点指针</span><br>&#125;<br><br><span class="hljs-comment">// 创建一个新的MinTree</span><br><span class="hljs-comment">// capacity: MinTree的容量</span><br><span class="hljs-keyword">struct</span> MinTree* <span class="hljs-title function_">createMinTree</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span>* <span class="hljs-title">minTree</span> =</span> (<span class="hljs-keyword">struct</span> MinTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> MinTree)); <span class="hljs-comment">// 为MinTree分配内存空间</span><br>    minTree-&gt;size = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化MinTree的节点数为0</span><br>    minTree-&gt;capacity = capacity; <span class="hljs-comment">// 设置MinTree的容量</span><br>    minTree-&gt;<span class="hljs-built_in">array</span> = (<span class="hljs-keyword">struct</span> Node**)<span class="hljs-built_in">malloc</span>(capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node*)); <span class="hljs-comment">// 为存储节点的指针数组分配内存空间</span><br>    <span class="hljs-keyword">return</span> minTree; <span class="hljs-comment">// 返回创建的MinTree的指针</span><br>&#125;<br><br><span class="hljs-comment">// 交换两个节点的指针</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swapNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node** a, <span class="hljs-keyword">struct</span> Node** b)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">t</span> =</span> *a; <span class="hljs-comment">// 临时变量保存第一个节点的指针指向的节点</span><br>    *a = *b; <span class="hljs-comment">// 将第二个节点的指针赋值给第一个节点的指针</span><br>    *b = t; <span class="hljs-comment">// 将临时变量保存的第一个节点的指针赋值给第二个节点的指针</span><br>&#125;<br><br><span class="hljs-comment">// 将最小树中以指定索引为根节点的子树变成最小堆</span><br><span class="hljs-comment">// minTree: 最小树的指针</span><br><span class="hljs-comment">// idx: 子树的根节点索引</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minTreeify</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-type">int</span> smallest = idx; <span class="hljs-comment">// 假设根节点的值最小</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子节点的索引</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>; <span class="hljs-comment">// 右子节点的索引</span><br>    <span class="hljs-comment">// 如果左子节点存在且频率比当前最小节点小，则更新最小节点索引</span><br>    <span class="hljs-keyword">if</span> (left &lt; minTree-&gt;size &amp;&amp; minTree-&gt;<span class="hljs-built_in">array</span>[left]-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[smallest]-&gt;frequency)<br>        smallest = left;<br>    <span class="hljs-comment">// 如果右子节点存在且频率比当前最小节点小，则更新最小节点索引</span><br>    <span class="hljs-keyword">if</span> (right &lt; minTree-&gt;size &amp;&amp; minTree-&gt;<span class="hljs-built_in">array</span>[right]-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[smallest]-&gt;frequency)<br>        smallest = right;<br>    <span class="hljs-comment">// 如果最小节点不是根节点，则交换最小节点和根节点，并对交换后的子树进行调整</span><br>    <span class="hljs-keyword">if</span> (smallest != idx) &#123;<br>        swapNode(&amp;minTree-&gt;<span class="hljs-built_in">array</span>[smallest], &amp;minTree-&gt;<span class="hljs-built_in">array</span>[idx]);<br>        minTreeify(minTree, smallest);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断MinTree是否只有一个节点</span><br><span class="hljs-comment">// minTree: MinTree指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isSizeOne</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree)</span> &#123;<br>    <span class="hljs-keyword">return</span> (minTree-&gt;size == <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 从MinTree中提取最小节点</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">extractMin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">temp</span> =</span> minTree-&gt;<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 保存需要提取的最小节点</span><br>    minTree-&gt;<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = minTree-&gt;<span class="hljs-built_in">array</span>[minTree-&gt;size - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 将最后一个节点移到根节点位置</span><br>    --minTree-&gt;size; <span class="hljs-comment">// MinTree大小减1</span><br>    minTreeify(minTree, <span class="hljs-number">0</span>); <span class="hljs-comment">// 重新调整MinTree的堆序性质</span><br>    <span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// 返回被提取的最小节点</span><br>&#125;<br><br><span class="hljs-comment">// 向MinTree中插入一个节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertMinTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree, <span class="hljs-keyword">struct</span> Node* node)</span> &#123;<br>    ++minTree-&gt;size; <span class="hljs-comment">// MinTree大小增加1</span><br>    <span class="hljs-type">int</span> i = minTree-&gt;size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &amp;&amp; node-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]-&gt;frequency) &#123;<br>        minTree-&gt;<span class="hljs-built_in">array</span>[i] = minTree-&gt;<span class="hljs-built_in">array</span>[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]; <span class="hljs-comment">// 将父节点移到当前位置</span><br>        i = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新位置到父节点的位置</span><br>    &#125;<br>    minTree-&gt;<span class="hljs-built_in">array</span>[i] = node; <span class="hljs-comment">// 将新节点插入到对应位置</span><br>&#125;<br><br><span class="hljs-comment">// 以给定的数据和频率构建哈夫曼树</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">char</span> data[], <span class="hljs-type">int</span> frequency[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>, * <span class="hljs-title">right</span>, * <span class="hljs-title">top</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span>* <span class="hljs-title">minTree</span> =</span> createMinTree(size); <span class="hljs-comment">// 创建一个最小堆，用于构建哈夫曼树</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequency[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            minTree-&gt;<span class="hljs-built_in">array</span>[minTree-&gt;size++] = newNode(data[i], frequency[i]); <span class="hljs-comment">// 将节点插入最小堆中</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最小堆化，使堆顶元素为最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = minTree-&gt;size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        minTreeify(minTree, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过不断取出堆顶和次堆顶的方式，构建哈夫曼树</span><br>    <span class="hljs-keyword">while</span> (!isSizeOne(minTree)) &#123;<br>        left = extractMin(minTree); <span class="hljs-comment">// 取出最小的节点作为左子树</span><br>        right = extractMin(minTree); <span class="hljs-comment">// 取出次小的节点作为右子树</span><br>        top = newNode(<span class="hljs-string">&#x27;$&#x27;</span>, left-&gt;frequency + right-&gt;frequency); <span class="hljs-comment">// 创建一个新的节点作为父节点</span><br>        top-&gt;left = left; <span class="hljs-comment">// 左子节点</span><br>        top-&gt;right = right; <span class="hljs-comment">// 右子节点</span><br>        insertMinTree(minTree, top); <span class="hljs-comment">// 将新节点插入最小堆中</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extractMin(minTree); <span class="hljs-comment">// 最后返回哈夫曼树的根节点</span><br>&#125;<br><br><span class="hljs-comment">// 递归打印哈夫曼编码</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printCodes</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* root, <span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> top)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于控制输出格式</span><br>    <span class="hljs-keyword">if</span> (!(root-&gt;left) &amp;&amp; !(root-&gt;right)) &#123; <span class="hljs-comment">// 当前节点为叶子节点</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Character: %c, Weight: %u, Huffman Code: &quot;</span>, root-&gt;data, root-&gt;frequency); <span class="hljs-comment">// 输出字符、频率和编码</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; ++i) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[i]); <span class="hljs-comment">// 遍历路径数组，打印编码</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (first) &#123; <span class="hljs-comment">// 第一次打印该编码时，在最后不需要加换行符</span><br>            first = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left) &#123; <span class="hljs-comment">// 遍历左子树，将路径加入数组，并递归遍历子树</span><br>        arr[top] = <span class="hljs-number">0</span>;<br>        printCodes(root-&gt;left, arr, top + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;right) &#123; <span class="hljs-comment">// 遍历右子树，将路径加入数组，并递归遍历子树</span><br>        arr[top] = <span class="hljs-number">1</span>;<br>        printCodes(root-&gt;right, arr, top + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> characters[MAX_CHARACTERS];<br>    <span class="hljs-type">int</span> frequencies[MAX_CHARACTERS] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of characters: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter %d characters: &quot;</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;characters[i]);<br>        frequencies[(<span class="hljs-type">int</span>)characters[i]]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> L_chars = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CHARACTERS; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequencies[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            L_chars++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">char</span> L_characters[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> L_frequencies[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CHARACTERS; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequencies[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            L_characters[index] = (<span class="hljs-type">char</span>)i;<br>            L_frequencies[index] = frequencies[i];<br>            index++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">root</span> =</span> buildHuffmanTree(L_characters, L_frequencies, L_chars);<br><br>    <span class="hljs-type">int</span> arr[MAX_CHARACTERS], top_index = <span class="hljs-number">0</span>;<br>    printCodes(root, arr, top_index);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>共享栈</title>
    <link href="/2023/10/23/%E5%85%B1%E4%BA%AB%E6%A0%88/"/>
    <url>/2023/10/23/%E5%85%B1%E4%BA%AB%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>共享栈是一种特殊的栈结构，它允许两个栈共享同一段物理内存区域。共享栈有两个栈顶指针，分别称为top 1和top 2，它们分别指向两个栈的栈顶元素。在共享栈中，两个栈可以分别从两端向中间生长，当它们的栈顶指针相遇时，表示共享栈已满。</p><p>下面是共享栈的基本操作：</p><ol><li>初始化（Init）：创建一个空的共享栈，并初始化top 1和top 2指针为-1，表示两个栈为空。</li><li>入栈（Push）：<ul><li>当要插入元素到栈1时，先检查top 1是否小于top 2-1，如果是，则将元素插入top 1位置，top 1加1。</li><li>当要插入元素到栈2时，先检查top 1是否小于top 2-1，如果是，则将元素插入top 2位置，top 2减1。</li></ul></li><li>出栈（Pop）：<ul><li>当要从栈1中出栈时，首先检查top 1是否不等于-1，如果是，则将top 1位置的元素弹出，并将top 1减1。</li><li>当要从栈2中出栈时，首先检查top 2是否不等于-1，如果是，则将top 2位置的元素弹出，并将top 2加1。</li></ul></li><li>判空（Is Empty）：检查top 1和top 2是否都为-1，如果是，则共享栈为空。</li><li>判满（Is Full）：检查top 1和top 2是否相差为1，如果是，则共享栈已满。</li><li>获取栈顶元素（Top）：<ul><li>当要获取栈1的栈顶元素时，首先检查top 1是否不等于-1，如果是，则返回top 1位置的元素。</li><li>当要获取栈2的栈顶元素时，首先检查top 2是否不等于-1，如果是，则返回top 2位置的元素。</li></ul></li></ol><p>以下是共享栈的伪代码实现，包括初始化、入栈、出栈和获取栈顶元素等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType data[MAX_SIZE];<br>    <span class="hljs-type">int</span> top1;  <span class="hljs-comment">// 第一个栈的栈顶指针</span><br>    <span class="hljs-type">int</span> top2;  <span class="hljs-comment">// 第二个栈的栈顶指针</span><br>&#125; SharedStack;<br><span class="hljs-comment">//栈满条件：top1 + 1 = top2</span><br><br><span class="hljs-comment">// 初始化共享栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initSharedStack</span><span class="hljs-params">(SharedStack &amp;S)</span> </span><br><span class="hljs-function"></span>&#123;<br>    S.top1 = <span class="hljs-number">-1</span>;<br>    S.top2 = MAX_SIZE;<br>&#125;<br><br><span class="hljs-comment">// 第一个栈的入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pushStack1</span><span class="hljs-params">(SharedStack &amp;S, ElemType x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top1 + <span class="hljs-number">1</span> &lt; S.top2) <br>    &#123;<span class="hljs-comment">//指针先加1，再入栈</span><br>        S.top1++;<br>        S.data[S.top1] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已满，无法进行入栈操作\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第一个栈的出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popStack1</span><span class="hljs-params">(SharedStack &amp;S, ElemType &amp;x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top1 &gt;= <span class="hljs-number">0</span>) <br>    &#123;<span class="hljs-comment">//先出栈，指针再减1</span><br>        x = S.data[S.top1];<br>        S.top1--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示栈为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二个栈的入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pushStack2</span><span class="hljs-params">(SharedStack &amp;S, ElemType x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top2 - <span class="hljs-number">1</span> &gt; S.top1) <br>    &#123;<span class="hljs-comment">//指针先减1，再入栈</span><br>        S.top2--;<br>        S.data[S.top2] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已满，无法进行入栈操作\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 第二个栈的出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popStack2</span><span class="hljs-params">(SharedStack &amp;S, ElemType &amp;x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top2 &lt; MAX_SIZE) <br>    &#123;<span class="hljs-comment">//先入栈，指针再加1</span><br>        x = S.data[S.top2];<br>        S.top2++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已空，无法进行出栈操作\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示栈为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getTopElement</span><span class="hljs-params">(SharedStack S, ElemType &amp;x)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top1 &gt;= <span class="hljs-number">0</span>) <br>    &#123;<br>       <span class="hljs-keyword">return</span> S.data[S.top1];<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S.top2 &lt; MAX_SIZE) <br>    &#123;<br>        <span class="hljs-keyword">return</span> S.data[S.top2];<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已空，无栈顶元素\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示栈为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转换函数</title>
    <link href="/2022/11/15/2022212741%E6%9D%8E%E6%98%8E/"/>
    <url>/2022/11/15/2022212741%E6%9D%8E%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h5 id="实现十进制数字到任意进制的转换函数"><a href="#实现十进制数字到任意进制的转换函数" class="headerlink" title="实现十进制数字到任意进制的转换函数:"></a>实现十进制数字到任意进制的转换函数:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">baseConverter</span><span class="hljs-params">(<span class="hljs-type">int</span> dec,<span class="hljs-type">int</span> base)</span>;<br><span class="hljs-comment">//其中base为转换的基数</span><br><span class="hljs-comment">//示例：</span><br>--&gt;input   :<span class="hljs-number">250</span>, <span class="hljs-number">16</span><br>--&gt;output  :FA<br></code></pre></td></tr></table></figure><h4 id="查资料："><a href="#查资料：" class="headerlink" title="查资料："></a>查资料：</h4><p>基数：在一种数制中，只能使用一组固定的数字来表示数的大小，这组固定的数字的个数就称为该计数制的基数（Base）。例如十进制的基数为10，二进制的基数为2等。</p><p>权：又称为位权或权值，即每一个数位都有一个固定的基值与之相对应，称之为权。如十进制的个位对应的权值为1（100），十位对应的权值为10（101），百位对应的权值为100（102）。对于一个 M 进制的数来说，小数点左边各位上对应的权值从右到左分别为基数的0次方、基数的1次方、基数的2次方等，对于小数点右边各位上对应的权值从左到右分别为基数的-1次方、基数的-2次方等。<br>二进制、八进制、十六进制向十进制转换：按权展开相加。<br>十进制转换成二进制、八进制、十六进制：整数部分除以基数取余数（取余的方向为从后向前）；小数部分乘以基数取整数（取整的方向为从前向后）。<br>二进制、八进制、十六进制相互转换：先转换成十进制再转换成其他进制；或者按照其对应关系进行转换（三位二进制数对应一位八进制数，四位二进制数对应一位十六进制数）。</p><h4 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h4><p>十六进制是由 0~F 这一组固定的数字来表示，所以釆用字符数组进行存储。<br>在执行程序时可以输入多组数据来验证程序的正确性</p><h4 id="程序源码："><a href="#程序源码：" class="headerlink" title="程序源码："></a>程序源码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">baseConverter</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j, num[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> k[] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span> &#125;;<br><span class="hljs-keyword">do</span> &#123;<br>i++;<br>num[i] = a % b;<br>a /= b;<br>&#125; <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (j = i; j &gt;= <span class="hljs-number">1</span>; j--)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, k[num[j]]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);<br>baseConverter(i,j);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行实例："><a href="#运行实例：" class="headerlink" title="运行实例："></a>运行实例：</h4><p><img src="/../img/1.png"></p><p><img src="/../img/2.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/13/hello-world/"/>
    <url>/2022/10/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
