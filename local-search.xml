<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2023/11/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>以下代码：首先统计了输入字符序列中每个字符出现的次数，然后基于这些统计结果构建了哈夫曼树，并生成了相应的哈夫曼编码和权重</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CHARACTERS 256</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">char</span> data; <span class="hljs-comment">// 节点存储的数据</span><br>    <span class="hljs-type">int</span> frequency; <span class="hljs-comment">// 节点的频率</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>, * <span class="hljs-title">right</span>;</span> <span class="hljs-comment">// 左子节点和右子节点的指针</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span> &#123;</span><br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">// MinTree中存储的节点数</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// MinTree的容量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>** <span class="hljs-title">array</span>;</span> <span class="hljs-comment">// 存储节点的指针数组</span><br>&#125;;<br><br><span class="hljs-comment">// 创建一个新的节点</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data, <span class="hljs-type">int</span> frequency)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <span class="hljs-comment">// 为节点分配内存空间</span><br>    node-&gt;left = node-&gt;right = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 初始化左子节点和右子节点指针为空</span><br>    node-&gt;data = data; <span class="hljs-comment">// 设置节点存储的数据</span><br>    node-&gt;frequency = frequency; <span class="hljs-comment">// 设置节点的频率</span><br>    <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// 返回创建的节点指针</span><br>&#125;<br><br><span class="hljs-comment">// 创建一个新的MinTree</span><br><span class="hljs-comment">// capacity: MinTree的容量</span><br><span class="hljs-keyword">struct</span> MinTree* <span class="hljs-title function_">createMinTree</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span>* <span class="hljs-title">minTree</span> =</span> (<span class="hljs-keyword">struct</span> MinTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> MinTree)); <span class="hljs-comment">// 为MinTree分配内存空间</span><br>    minTree-&gt;size = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化MinTree的节点数为0</span><br>    minTree-&gt;capacity = capacity; <span class="hljs-comment">// 设置MinTree的容量</span><br>    minTree-&gt;<span class="hljs-built_in">array</span> = (<span class="hljs-keyword">struct</span> Node**)<span class="hljs-built_in">malloc</span>(capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node*)); <span class="hljs-comment">// 为存储节点的指针数组分配内存空间</span><br>    <span class="hljs-keyword">return</span> minTree; <span class="hljs-comment">// 返回创建的MinTree的指针</span><br>&#125;<br><br><span class="hljs-comment">// 交换两个节点的指针</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swapNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node** a, <span class="hljs-keyword">struct</span> Node** b)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">t</span> =</span> *a; <span class="hljs-comment">// 临时变量保存第一个节点的指针指向的节点</span><br>    *a = *b; <span class="hljs-comment">// 将第二个节点的指针赋值给第一个节点的指针</span><br>    *b = t; <span class="hljs-comment">// 将临时变量保存的第一个节点的指针赋值给第二个节点的指针</span><br>&#125;<br><br><span class="hljs-comment">// 将最小树中以指定索引为根节点的子树变成最小堆</span><br><span class="hljs-comment">// minTree: 最小树的指针</span><br><span class="hljs-comment">// idx: 子树的根节点索引</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minTreeify</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-type">int</span> smallest = idx; <span class="hljs-comment">// 假设根节点的值最小</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子节点的索引</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>; <span class="hljs-comment">// 右子节点的索引</span><br>    <span class="hljs-comment">// 如果左子节点存在且频率比当前最小节点小，则更新最小节点索引</span><br>    <span class="hljs-keyword">if</span> (left &lt; minTree-&gt;size &amp;&amp; minTree-&gt;<span class="hljs-built_in">array</span>[left]-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[smallest]-&gt;frequency)<br>        smallest = left;<br>    <span class="hljs-comment">// 如果右子节点存在且频率比当前最小节点小，则更新最小节点索引</span><br>    <span class="hljs-keyword">if</span> (right &lt; minTree-&gt;size &amp;&amp; minTree-&gt;<span class="hljs-built_in">array</span>[right]-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[smallest]-&gt;frequency)<br>        smallest = right;<br>    <span class="hljs-comment">// 如果最小节点不是根节点，则交换最小节点和根节点，并对交换后的子树进行调整</span><br>    <span class="hljs-keyword">if</span> (smallest != idx) &#123;<br>        swapNode(&amp;minTree-&gt;<span class="hljs-built_in">array</span>[smallest], &amp;minTree-&gt;<span class="hljs-built_in">array</span>[idx]);<br>        minTreeify(minTree, smallest);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断MinTree是否只有一个节点</span><br><span class="hljs-comment">// minTree: MinTree指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isSizeOne</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree)</span> &#123;<br>    <span class="hljs-keyword">return</span> (minTree-&gt;size == <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 从MinTree中提取最小节点</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">extractMin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">temp</span> =</span> minTree-&gt;<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 保存需要提取的最小节点</span><br>    minTree-&gt;<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = minTree-&gt;<span class="hljs-built_in">array</span>[minTree-&gt;size - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 将最后一个节点移到根节点位置</span><br>    --minTree-&gt;size; <span class="hljs-comment">// MinTree大小减1</span><br>    minTreeify(minTree, <span class="hljs-number">0</span>); <span class="hljs-comment">// 重新调整MinTree的堆序性质</span><br>    <span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// 返回被提取的最小节点</span><br>&#125;<br><br><span class="hljs-comment">// 向MinTree中插入一个节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertMinTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> MinTree* minTree, <span class="hljs-keyword">struct</span> Node* node)</span> &#123;<br>    ++minTree-&gt;size; <span class="hljs-comment">// MinTree大小增加1</span><br>    <span class="hljs-type">int</span> i = minTree-&gt;size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &amp;&amp; node-&gt;frequency &lt; minTree-&gt;<span class="hljs-built_in">array</span>[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]-&gt;frequency) &#123;<br>        minTree-&gt;<span class="hljs-built_in">array</span>[i] = minTree-&gt;<span class="hljs-built_in">array</span>[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]; <span class="hljs-comment">// 将父节点移到当前位置</span><br>        i = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新位置到父节点的位置</span><br>    &#125;<br>    minTree-&gt;<span class="hljs-built_in">array</span>[i] = node; <span class="hljs-comment">// 将新节点插入到对应位置</span><br>&#125;<br><br><span class="hljs-comment">// 以给定的数据和频率构建哈夫曼树</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">char</span> data[], <span class="hljs-type">int</span> frequency[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>, * <span class="hljs-title">right</span>, * <span class="hljs-title">top</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinTree</span>* <span class="hljs-title">minTree</span> =</span> createMinTree(size); <span class="hljs-comment">// 创建一个最小堆，用于构建哈夫曼树</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequency[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            minTree-&gt;<span class="hljs-built_in">array</span>[minTree-&gt;size++] = newNode(data[i], frequency[i]); <span class="hljs-comment">// 将节点插入最小堆中</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最小堆化，使堆顶元素为最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = minTree-&gt;size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        minTreeify(minTree, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过不断取出堆顶和次堆顶的方式，构建哈夫曼树</span><br>    <span class="hljs-keyword">while</span> (!isSizeOne(minTree)) &#123;<br>        left = extractMin(minTree); <span class="hljs-comment">// 取出最小的节点作为左子树</span><br>        right = extractMin(minTree); <span class="hljs-comment">// 取出次小的节点作为右子树</span><br>        top = newNode(<span class="hljs-string">&#x27;$&#x27;</span>, left-&gt;frequency + right-&gt;frequency); <span class="hljs-comment">// 创建一个新的节点作为父节点</span><br>        top-&gt;left = left; <span class="hljs-comment">// 左子节点</span><br>        top-&gt;right = right; <span class="hljs-comment">// 右子节点</span><br>        insertMinTree(minTree, top); <span class="hljs-comment">// 将新节点插入最小堆中</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extractMin(minTree); <span class="hljs-comment">// 最后返回哈夫曼树的根节点</span><br>&#125;<br><br><span class="hljs-comment">// 递归打印哈夫曼编码</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printCodes</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* root, <span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> top)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于控制输出格式</span><br>    <span class="hljs-keyword">if</span> (!(root-&gt;left) &amp;&amp; !(root-&gt;right)) &#123; <span class="hljs-comment">// 当前节点为叶子节点</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Character: %c, Weight: %u, Huffman Code: &quot;</span>, root-&gt;data, root-&gt;frequency); <span class="hljs-comment">// 输出字符、频率和编码</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; ++i) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[i]); <span class="hljs-comment">// 遍历路径数组，打印编码</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (first) &#123; <span class="hljs-comment">// 第一次打印该编码时，在最后不需要加换行符</span><br>            first = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left) &#123; <span class="hljs-comment">// 遍历左子树，将路径加入数组，并递归遍历子树</span><br>        arr[top] = <span class="hljs-number">0</span>;<br>        printCodes(root-&gt;left, arr, top + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;right) &#123; <span class="hljs-comment">// 遍历右子树，将路径加入数组，并递归遍历子树</span><br>        arr[top] = <span class="hljs-number">1</span>;<br>        printCodes(root-&gt;right, arr, top + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> characters[MAX_CHARACTERS];<br>    <span class="hljs-type">int</span> frequencies[MAX_CHARACTERS] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of characters: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter %d characters: &quot;</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;characters[i]);<br>        frequencies[(<span class="hljs-type">int</span>)characters[i]]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> L_chars = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CHARACTERS; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequencies[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            L_chars++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">char</span> L_characters[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> L_frequencies[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CHARACTERS; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (frequencies[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            L_characters[index] = (<span class="hljs-type">char</span>)i;<br>            L_frequencies[index] = frequencies[i];<br>            index++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">root</span> =</span> buildHuffmanTree(L_characters, L_frequencies, L_chars);<br><br>    <span class="hljs-type">int</span> arr[MAX_CHARACTERS], top_index = <span class="hljs-number">0</span>;<br>    printCodes(root, arr, top_index);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/2022/11/15/My-New-Post/"/>
    <url>/2022/11/15/My-New-Post/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转换函数</title>
    <link href="/2022/11/15/2022212741%E6%9D%8E%E6%98%8E/"/>
    <url>/2022/11/15/2022212741%E6%9D%8E%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h5 id="实现十进制数字到任意进制的转换函数"><a href="#实现十进制数字到任意进制的转换函数" class="headerlink" title="实现十进制数字到任意进制的转换函数:"></a>实现十进制数字到任意进制的转换函数:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">baseConverter</span><span class="hljs-params">(<span class="hljs-type">int</span> dec,<span class="hljs-type">int</span> base)</span>;<br><span class="hljs-comment">//其中base为转换的基数</span><br><span class="hljs-comment">//示例：</span><br>--&gt;input   :<span class="hljs-number">250</span>, <span class="hljs-number">16</span><br>--&gt;output  :FA<br></code></pre></td></tr></table></figure><h4 id="查资料："><a href="#查资料：" class="headerlink" title="查资料："></a>查资料：</h4><p>基数：在一种数制中，只能使用一组固定的数字来表示数的大小，这组固定的数字的个数就称为该计数制的基数（Base）。例如十进制的基数为10，二进制的基数为2等。</p><p>权：又称为位权或权值，即每一个数位都有一个固定的基值与之相对应，称之为权。如十进制的个位对应的权值为1（100），十位对应的权值为10（101），百位对应的权值为100（102）。对于一个 M 进制的数来说，小数点左边各位上对应的权值从右到左分别为基数的0次方、基数的1次方、基数的2次方等，对于小数点右边各位上对应的权值从左到右分别为基数的-1次方、基数的-2次方等。<br>二进制、八进制、十六进制向十进制转换：按权展开相加。<br>十进制转换成二进制、八进制、十六进制：整数部分除以基数取余数（取余的方向为从后向前）；小数部分乘以基数取整数（取整的方向为从前向后）。<br>二进制、八进制、十六进制相互转换：先转换成十进制再转换成其他进制；或者按照其对应关系进行转换（三位二进制数对应一位八进制数，四位二进制数对应一位十六进制数）。</p><h4 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h4><p>十六进制是由 0~F 这一组固定的数字来表示，所以釆用字符数组进行存储。<br>在执行程序时可以输入多组数据来验证程序的正确性</p><h4 id="程序源码："><a href="#程序源码：" class="headerlink" title="程序源码："></a>程序源码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">baseConverter</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j, num[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> k[] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span> &#125;;<br><span class="hljs-keyword">do</span> &#123;<br>i++;<br>num[i] = a % b;<br>a /= b;<br>&#125; <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (j = i; j &gt;= <span class="hljs-number">1</span>; j--)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, k[num[j]]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);<br>baseConverter(i,j);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行实例："><a href="#运行实例：" class="headerlink" title="运行实例："></a>运行实例：</h4><p><img src="/../img/1.png"></p><p><img src="/../img/2.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/13/hello-world/"/>
    <url>/2022/10/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
